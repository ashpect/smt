/**
 * @module @zk-kit/smt
 * @version 1.0.0
 * @file Sparse Merkle tree implementation in TypeScript.
 * @copyright Cedoor 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/smt}
*/
var zkKitSmt=function(t){"use strict";function e(t){let e=Number(`0x${t[0]}`).toString(2);for(let r=1;r<t.length;r+=1)e+=Number(`0x${t[r]}`).toString(2).padStart(4,"0");return e}function r(t){return("bigint"==typeof t?t.toString(2):e(t)).padStart(256,"0").split("").reverse().map(Number)}function s(t){for(let e=t.length-1;e>=0;e-=1)if(0!==Number(`0x${t[e]}`))return e;return-1}function n(t,e){const r=t.length<e.length?t:e;for(let s=0;s<r.length;s+=1)if(t[s]!==e[s])return r.slice(0,s);return r.slice()}function i(t){return"string"==typeof t&&/^[0-9A-Fa-f]{1,64}$/.test(t)}return t.SMT=class{constructor(t,e=!1){if(e){if("function"!=typeof BigInt)throw new Error("Big numbers are not supported");if("bigint"!=typeof t([BigInt(1),BigInt(1)]))throw new Error("The hash function must return a big number")}else if(!i(t(["1","1"])))throw new Error("The hash function must return a hexadecimal");this.hash=t,this.bigNumbers=e,this.zeroNode=e?BigInt(0):"0",this.entryMark=e?BigInt(1):"1",this.nodes=new Map,this.root=this.zeroNode}get(t){this.checkParameterType(t);const{entry:e}=this.retrieveEntry(t);return e[1]}add(t,e){this.checkParameterType(t),this.checkParameterType(e);const{entry:s,matchingEntry:n,siblings:i}=this.retrieveEntry(t);if(void 0!==s[1])throw new Error(`Key "${t}" already exists`);const o=r(t),h=n?this.hash(n):this.zeroNode;if(i.length>0&&this.deleteOldNodes(h,o,i),n){const t=r(n[0]);for(let e=i.length;t[e]===o[e];e+=1)i.push(this.zeroNode);i.push(h)}const a=this.hash([t,e,this.entryMark]);this.nodes.set(a,[t,e,this.entryMark]),this.root=this.addNewNodes(a,o,i)}update(t,e){this.checkParameterType(t),this.checkParameterType(e);const{entry:s,siblings:n}=this.retrieveEntry(t);if(void 0===s[1])throw new Error(`Key "${t}" does not exist`);const i=r(t),o=this.hash(s);this.nodes.delete(o),this.deleteOldNodes(o,i,n);const h=this.hash([t,e,this.entryMark]);this.nodes.set(h,[t,e,this.entryMark]),this.root=this.addNewNodes(h,i,n)}delete(t){this.checkParameterType(t);const{entry:e,siblings:n}=this.retrieveEntry(t);if(void 0===e[1])throw new Error(`Key "${t}" does not exist`);const i=r(t),o=this.hash(e);if(this.nodes.delete(o),this.root=this.zeroNode,n.length>0)if(this.deleteOldNodes(o,i,n),this.isLeaf(n[n.length-1])){const t=n.pop(),e=s(n);this.root=this.addNewNodes(t,i,n,e)}else this.root=this.addNewNodes(this.zeroNode,i,n)}createProof(t){this.checkParameterType(t);const{entry:e,matchingEntry:r,siblings:s}=this.retrieveEntry(t);return{entry:e,matchingEntry:r,siblings:s,root:this.root,membership:!!e[1]}}verifyProof(t){if(!t.matchingEntry){const e=r(t.entry[0]),s=void 0!==t.entry[1]?this.hash(t.entry):this.zeroNode;return this.calculateRoot(s,e,t.siblings)===t.root}const e=r(t.matchingEntry[0]),s=this.hash(t.matchingEntry);if(this.calculateRoot(s,e,t.siblings)===t.root){const s=n(r(t.entry[0]),e);return t.siblings.length<=s.length}return!1}export(){const t={};return this.nodes.forEach(((e,r)=>{t[r.toString()]=e.map((t=>t.toString()))})),JSON.stringify(t,null,2)}import(t){const e=JSON.parse(t),r=new Map;for(const[t,s]of Object.entries(e)){const e=BigInt(t),n=s.map((t=>BigInt(t)));r.set(e,n)}this.nodes=r}retrieveEntry(t){const e=r(t),s=[];for(let r=0,n=this.root;n!==this.zeroNode;r+=1){const i=this.nodes.get(n),o=e[r];if(i[2])return i[0]===t?{entry:i,siblings:s}:{entry:[t],matchingEntry:i,siblings:s};n=i[o],s.push(i[Number(!o)])}return{entry:[t],siblings:s}}calculateRoot(t,e,r){for(let s=r.length-1;s>=0;s-=1){const n=e[s]?[r[s],t]:[t,r[s]];t=this.hash(n)}return t}addNewNodes(t,e,r,s=r.length-1){for(;s>=0;s-=1){const n=e[s]?[r[s],t]:[t,r[s]];t=this.hash(n),this.nodes.set(t,n)}return t}deleteOldNodes(t,e,r){for(let s=r.length-1;s>=0;s-=1){const n=e[s]?[r[s],t]:[t,r[s]];t=this.hash(n),this.nodes.delete(t)}}isLeaf(t){const e=this.nodes.get(t);return!(!e||!e[2])}checkParameterType(t){if(this.bigNumbers&&"bigint"!=typeof t)throw new Error(`Parameter ${t} must be a big number`);if(!this.bigNumbers&&!i(t))throw new Error(`Parameter ${t} must be a hexadecimal`)}},t.checkHex=i,t.getFirstCommonElements=n,t.getIndexOfLastNonZeroElement=s,t.hexToBin=e,t.keyToPath=r,t}({});
